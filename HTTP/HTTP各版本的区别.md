## http0.9

    满足最基础的html文档传输

    1. 只有一个请求行
    2. 没有请求头请求体，之传输简单的ASCII字符流传输
    3. 基于TCP

    缺点：
     
      不支持多种数据类型（javascript, css, 图片， 音频等）

## http1.0

    支持多种类型的文件下载传输

    1. 添加了请求头请求体
    2. 对数据进行压缩 
    3. 添加状态码
    4. 添加cache机制缓存已下载的数据
    5. 用户代理字段
 
```javascript

// 基础的请求头 
accept: text/html; // 请求类型
accept-encoding: gzip, deflate, br; // 压缩方式
accept-Charset: ISO-8859-1,utf-8; // 编码形式
accept-language: zh-CN,zh; // 语言

// 响应头 
content-encoding: br; // 不支持gzip 就返回br
content-type: text/html; charset=UTF-8;
```

    缺点： 

        每次请求都需要建立tcp链接传输数据断开tcp链接，耗性能。

## http1.1

    tcp持久连接

    1. TCP只要不断开那么就可以一直传输数据
    2. 默认开启持久连接，不需要设置请求头
    3. 添加Host字段 表示当前域名 （虚拟主机实现了一个ip多个域名） 
    5. 客户端Cookie、安全机制（https）

    目前浏览器只允许同时建立6个TCP持久连接

```javascript
    
Connection: close // 关闭持久连接
    
```
      
    虚拟主机支持：

        HTTP/1.0每个域名绑定了一个唯一的IP地址，因此一个服务器只能支持一个域名。
        虚拟主机可以实现一个物理主机上绑定多个虚拟主机。每个虚拟主机都有单独的域名，
        域名都是公用同一个IP地址。

        因此请求头添加了host字段，表示当前的域名，这样服务器就可以根据不同host值做不同的处理。

    动态生成的内容提供支持：

        http1.0 content-length字段设置完整的数据大小，浏览器根据设置的数据大小接收数据。
        随着技术发展，很多页面的内容都是动态生成，因此在传输数据时不知道最终数据大小。

        http1.1引入了Chunk transfer机制解决。服务器会将数据分割成若干个任意大小的数据块，
        每个数据块会有当前块的长度，最后使用一个0长度的数据块作为发送数据完成标志。
        

    缺点：

        1.TCP启动慢
        2.多条TCP竞争带宽（一个域名6个TCP）

        3.队首阻塞问题：
            持久连接虽然减少TCP建立断开次数，但是请求需要排队。
            如果前面的请求没有及时返回那么就会阻塞后面的请求。

        队首阻塞问题解决方案：

            1.HTTP管线化-放弃

                将多个HTTP请求整批的交给服务器，但是服务器还是需要根据请求顺序来回复浏览器
      
## http2.0

    提升网络速度

    1. 多路复用（解决应用层面队首阻塞问题）
    2. 一个域名只使用一个TCP（解决TCP启动慢，TCP带宽竞争）
    3. 可设置请求优先级
    4. 服务器推送（提前将数据推送给浏览器）
    5. 头部压缩（请求头响应头）
    
    多路复用实现：

        添加了二进制分帧层
        1. 浏览器的请求数据进过二进制分帧层处理之后，会被转换成带有ID编号的帧
        2. 通过协议将帧发送给服务器
        3. 服务器将相同ID的帧合并为一条完整的请求信息
        4. 服务器处理请求将处理的响应行 响应头 响应体分别发送至二进制分帧层
        5. 二进制分帧层将请求处理，转换成带有ID编号的帧，发送给浏览器
        6. 浏览器接收到响应，根据ID编号将帧数据提交给对应的请求

    缺点：
        TCP本身得问题
        TCP建立连接过慢
        TCP本来就是为了单连接而设计，还是存在队首阻塞问题
        丢包率过高（2%）那么传输效率还不如http1.1 

    RTT-网络延迟（浏览器发送一个数据包到服务器，再从服务器返回数据包到浏览器的整个往返时间称为 RTT）
        TCP的三次握手就需要1.5个RTT
        进行 TLS 连接(HTTPS) 需要1~2个RTT

        一个RTT大于10ms 距离过远可能需要100ms

## http3.0

    替换传输协议使用UDP QUIC协议

    TCP协议僵化导致对TCP改造过于困难
        1. 中间设备的僵化
            · 这些设备包括了路由器、防火墙、NAT、交换机等。它们通常依赖一些很少升级的软件，这些软件使用了大量的 TCP 特性，这些功能被设置之后就很少更新了。
            · 我们在客户端升级了 TCP 协议，但是当新协议的数据包经过这些中间设备时，它们可能不理解包的内容，于是这些数据就会被丢弃掉。这就是中间设备僵化，它是阻碍 TCP 更新的一大障碍。

        2. 操作系统导致 TCP 协议僵化
            · TCP 协议都是通过操作系统内核来实现的，应用程序只能使用不能修改
            · 通常操作系统的更新都滞后于软件的更新，因此要想自由地更新内核中的 TCP 协议也是非常困难的
    
    所以另辟蹊径（找到一种中间设备支持的并且能解决当前TCP遗留问题的协议）

    QUIC协议
        基于 UDP 实现了类似于 TCP 的多路数据流、传输可靠性等功能，我们把这套功能称为QUIC 协议。

    优点：
        1. 实现了类似TCP的流量控制、传输可靠性的功能
        2. 集成了TLS加密功能
        3. 实现了HTTP2的多路复用功能，而且对比TCP实现了同一物理链接上有多个独立的逻辑数据流(不存在队首阻塞问题了)

    HTTP3.0当前问题

        1. 服务器浏览器都没有对HTTP3.0进行很好的支持
        2. 系统内核对UDP的支持不如TCP的好
        3. 中间设备僵化问题，对UDP的支持不如TCP，QUIC运行时丢包率3%~7%





